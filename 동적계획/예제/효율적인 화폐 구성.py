"""
화폐의 수 n과 원하는 수 m을 받아서 처리한다.
다음으로 화폐의 크기가 주어지면, 주어진 화폐의 최소 사용으로 m을 구한다.
m을 구할 수 없을 경우에는 -1을 출력.
- 모든 원하는 값을 찾는 배열을 하나 만든다.
- 배열을 주어진 화폐 수 만큼 반복 탐색하면서 주어진 화폐 크기로 구성이 되는지 체크한다.
- 이때 0번 인덱스는 사용하지 않으므로 인덱스를 +1 해준다.
- (i-k)가 INF가 아닌 값을 구한다.
"""
n, m = map(int, input().split())
array = []
for i in range(n):
    array.append(int(input()))
d = [10001] * (m+1) # 매우 큰 수로 초기화
d[0] = 0 # 보텀업
for i in range(n): # 화폐의 크기
    for j in range(array[i], m+1): # 원하는 값 순회
        if d[j - array[i]] != 10001: # (i-k)원을 만들 수 있으면
            d[j] = min(d[j], d[j-array[i]]+1)
if d[m] == 10001:
    print(-1)
else:
    print(d[m])
"""
2 15
2
3
=5
3 4
3
5
7
=-1
3 7
2
3
5
=2
"""